<!DOCTYPE html>
<html>
    <style>
        #textbox,#title,#SwitchMode {
            position: absolute;
            color: #eee;
            cursor: move;
            font-family: "Comfortaa", sans-serif;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }html, body {
            position: relative;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }button {
            background-color: transparent;
            background-repeat: no-repeat;
            border: none;
            cursor: pointer;
            border: 2px solid white;
            border-radius: 5px;
            overflow: hidden;
            color: #eee;
            font-family: "Comfortaa", sans-serif;
        }button:hover{
            transform: scale(0.9);
            transition: 0.5s ease;
        }
    </style>
    <head>
        <script src="matter.js"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300..700&display=swap" rel="stylesheet">
    </head>
    <!--The body is where the actual canvas is projected to-->
    <canvas id="CANVAS"></canvas>
    
    <body>
        <div id="title" style="top:5vh;width:80vw">
            <h1>Wagoogus</h1>
        </div>

        <div id="SwitchMode" style="top:15vh;width:80vw">
            <button id="switchModeButton" onclick="switchPlacementMode()">Currently:<br> Place Mode</button>
            <button id="switchTypeButton" onclick="switchTypeMode()">Currently: <br> Tile</button>
        </div>
    </body>
    <script>
        var mouseX = 0;
        var mouseY = 0
        var canvas = document.getElementById("CANVAS");
        var mode = "place"
        var type = "tile"

        function getMousePosition(canvas, event) {
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            mouseX = x;
            mouseY = y;
        }

    // module aliases
    var Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Body = Matter.Body,
        Composite = Matter.Composite,
        Composites = Matter.Composites,
        Mouse = Matter.Mouse,
        MouseConstraint = Matter.MouseConstraint,
        Constraint = Matter.Constraint,
        Events = Matter.Events,
        Bounds = Matter.Bounds
        
    // create an engine
    var engine = Engine.create();

    // create a renderer
    var render = Render.create({
        canvas: canvas,
        engine: engine,
        
        options: {
            pixelRatio: window.devicePixelRatio,
            wireframes: false,
            hasBounds: true,
            width: window.innerWidth, 
            height: window.innerHeight
        }
       
    });


    canvas.width = window.innerWidth
    
    canvas.height = window.innerHeight

   Composites.softBody(200, 100, 10, 10, 0, 0, true, 3, particleOptions, constraintOptions);

    var particleOptions = { 
        friction: 0.5,
        frictionStatic: 4,
        render: { 
            visible: true,
            wireframes: false
        } 
    };

    //Adjusts player particles, including fricion and friction static parameters
    var playerParticleOptions = { 
        friction: 0.1,
        frictionStatic: 0,
        render: { 
            visible: true,
            wireframes: false
        } 
    };

    

    var constraintOptions = { 
            render: { visible: false, wireframes: false }
    };

    var canvasmouse = Mouse.create(render.canvas);

    
    var mouseConstraintOptions = {
        mouse: canvasmouse,
        render: {
            visible: false
        }
    };


    var mConstraint = MouseConstraint.create(engine, mouseConstraintOptions)

     // create two boxes and a ground
     var ground = Bodies.rectangle(400, 610, 500, 60, { isStatic: true });
    //var wagoogustext = Bodies.rectangle(800, 70, 200, 60, { isStatic: true });
    var mouseBox = Bodies.rectangle(500, 100, 80, 80);
    
    //the player
    var playerBlob = Composites.softBody(250, 100, 3, 3, 0, 0, true, 12, playerParticleOptions, constraintOptions);
    
    document.addEventListener('keydown', (event)=> {    
        if(event.key == 'w'){
            //for(let i = 0; i < 3; i++){
                let i=4
                Body.applyForce(playerBlob.bodies[i], {x: playerBlob.bodies[i].position.x, y: playerBlob.bodies[i].position.y}, {x: 0, y: -0.04});
            //}
            
        }else if(event.key == 'd'){
            //for(let i = 6; i < 8; i++){
                let i=4
                Body.applyForce(playerBlob.bodies[i], {x: playerBlob.bodies[i].position.x, y: playerBlob.bodies[i].position.y}, {x: 0.01, y: 0});
            //}
        }else if(event.key == 'a'){
            //for(let i = 6; i < 8; i++){
                let i=4
                Body.applyForce(playerBlob.bodies[i], {x: playerBlob.bodies[i].position.x, y: playerBlob.bodies[i].position.y}, {x: -0.01, y: 0});
            //}
        }
    });
    

    function createChain(len, x, y, radius){

    
    var start = Bodies.circle(x, y, radius)

    var playerParticles = [start];

    var prev = null;

    var connectStart = false;
  

    for(let i = 0; i < len-1; i++){
        var p1 = Bodies.circle(x + 3 * i, y + 3 *i, radius)
        playerParticles.push(p1)

        if(!connectStart){
        var startConstraint = { 
            bodyA: start,
            bodyB: p1,
            length: 25,
            stiffness: 0.5,
            render:{
                visible: false
            }
        };
        var startingC = Constraint.create(startConstraint);
        Composite.add(engine.world, startingC)
        connectStart = true;
        }

        if(prev){
        var playerConstraint = { 
            bodyA: prev,
            bodyB: p1,
            length: 25,
            stiffness: 0.5,
            render:{
                visible: false
            }
        };
        var playConstraint = Constraint.create(playerConstraint);
        Composite.add(engine.world, playConstraint)
        }
        
        prev = p1;

    }

    var endConstraint = { 
            bodyA: prev,
            bodyB: start,
            length: 25,
            stiffness: 0.5,
            render:{
                visible: false
            }
        };
        var endingConstraint = Constraint.create(endConstraint);
        Composite.add(engine.world, endingConstraint)

    
    
    
    
    
    Composite.add(engine.world, playerParticles)
    }

    canvas.addEventListener("mousedown", function (e) {

        if(mode == "place"){
        //var correctedMouse = getCorrectedMousePosition(e);
        //mouseX = correctedMouse.x;
        //mouseY = correctedMouse.y;
        getMousePosition(canvas, e)
        console.log(mouseX, mouseY)
        var placementObj = null;
        if(type == "tile"){
            placementObj = Bodies.rectangle(mouseX, mouseY, 80, 80, {isStatic: true});
        }else{
            placementObj = Composites.softBody(mouseX, mouseY, 7, 7, 0, 0, true, 10, particleOptions, constraintOptions);
        }
        Composite.add(engine.world, placementObj); 
        }
    }); 

    function switchPlacementMode(){
        if(mode == "place"){
            mode="drag"
            document.getElementById("switchModeButton").innerHTML = "Currently: <br> Drag Mode"
        }else{
            mode="place"
            document.getElementById("switchModeButton").innerHTML  = "Currently: <br> Place Mode"
        }
    }


    function switchTypeMode(){
        if(type == "tile"){
            type="soft"
            document.getElementById("switchTypeButton").innerHTML = "Currently: <br> Soft Body"
        }else{
            type="tile"
            document.getElementById("switchTypeButton").innerHTML  = "Currently: <br> Tile"
        }
    }
    let cameraOffset={x:0, y:0}

    
    Events.on(engine, 'beforeUpdate', function(e) {
        var canvas = document.getElementById('CANVAS');
        
        // center view at player 
        Bounds.shift(render.bounds,
        {
            
            x: playerBlob.bodies[4].position.x - window.innerWidth / 2,
            y: playerBlob.bodies[4].position.y - window.innerHeight / 2
            
        });

        //Mouse.setOffset(mConstraint.mouse, {x: playerBlob.bodies[4].position.x + window.innerWidth / 2, y: playerBlob.bodies[4].position.y + window.innerHeight / 2});
        cameraOffset.x = ((playerBlob.bodies[4].position.x)*devicePixelRatio - (window.innerWidth / 2))*1;
        cameraOffset.y = ((playerBlob.bodies[4].position.y)*devicePixelRatio - (window.innerHeight / 2))*1;
        //console.log(cameraOffset.x + ", " + cameraOffset.y)
        //var correctedMouse = getCorrectedMousePosition(e);
        //mouseX = correctedMouse.x;
        //mouseY = correctedMouse.y;
    });


    function getCorrectedMousePosition(event) {

        var rect = canvas.getBoundingClientRect(); // Assumes canvas is your canvas element
    var scaleX = canvas.width / rect.width;    // Relationship bitmap vs. element for X
    var scaleY = canvas.height / rect.height;  // Relationship bitmap vs. element for Y

    // Calculate the mouse position corrected by the camera offset and canvas scaling
      mouseX = (event.clientX - rect.left) * scaleX - cameraOffset.x;
      mouseY = (event.clientY - rect.top) * scaleY - cameraOffset.y;

    return { x: mouseX, y: mouseY };
        //mouseX = canvasmouse.position.x - cameraOffset.x;
        //mouseY = canvasmouse.position.y - cameraOffset.y;
       
}


/*
function getCorrectedMousePosition(event) {
    var rect = canvas.getBoundingClientRect(); // Assumes canvas is your canvas element
    console.log("Canvas rect:", rect);
    var scaleX = canvas.width / rect.width;    // Relationship bitmap vs. element for X
    var scaleY = canvas.height / rect.height;  // Relationship bitmap vs. element for Y

    // Log raw mouse coordinates
    console.log("Raw mouse position:", event.clientX, event.clientY);

    // Calculate the mouse position corrected by the camera offset and canvas scaling
    var mouseyX = (event.clientX - rect.left) * scaleX - cameraOffset.x;
    var mouseyY = (event.clientY - rect.top) * scaleY - cameraOffset.y;
        console.log(scaleX + ", " + cameraOffset.x)
    // Log corrected mouse position
    console.log("Corrected mouse position:", mouseyX, mouseyY);

    return { x: mouseyX, y: mouseyY };
}
*/ 
document.addEventListener("mousemove", function(event) {
    console.log("Raw mouse position:", event.clientX, event.clientY);
    console.log("Canvas mouse position:", canvasmouse.position.x, canvasmouse.position.y);
});
    
    
    window.onresize = function() {
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;

    }
   
    //document.addEventListener("mousemove", function(event) {
    //var correctedMouse = getCorrectedMousePosition(event);
    //canvasmouse.position.x = correctedMouse.x;
    //canvasmouse.position.y = correctedMouse.y;
//});
    
       
    // add all of the bodies to the world
    Composite.add(engine.world, [ground,canvasmouse, mConstraint, mouseBox ,playerBlob]);
   
    // run the renderer
    Render.run(render);

    // create runner
    var runner = Runner.create();

    // run the engine
    Runner.run(runner, engine);

    var zoom = 2



</script>
</html>